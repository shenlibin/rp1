# 第一章



# 第二章 类加载



# 第三章 运行时数据区

 



## 05 虚拟机栈

内存中的栈与堆,栈是运行时单位,堆是存储的单位

### 栈

每个线程都会创建一个虚拟机栈,内部保存一个个栈帧(StackFrame),对应这一次次的Java方法调用,是线程私有的

​	生命周期和线程一致

​	作用:主管Java程序的运行,保存方法的局部变量,部分结果,并参与调用和返回,决定了能调用方法的深度。

​	优点:一种快速有效的分配储存方式,速度仅次于程序计数器

​		JVM直接对Java栈操作只有入栈(每个方法执行),出栈(方法结束)
​		不存在垃圾回收问题

​	通过设置-Xss参数,来设置每个线程的栈内存大小

​    不同线程之间的栈帧不能互相引用

​    java有2种方法弹出栈,return 或者抛出异常。

### 栈帧

#### 局部变量表(Local Variables)

​	包括了,形参,局部变量(基本类型,对象引用),大小多少决定了方法被调用的深度

​	表的单个储存单位(Slot/变量槽),32位以内的类型只占一个,64位的类型占2个(long,double)

​	基本类型byte ,short ,char,boolean 也被转成int

​	构造方法/实例方法 会将当前对象this放在index为0的slot处

​	slot可以重复利用,当前面的局部变量过了作用域,后面申明的变量会重复使用之前变量的槽

​	局部变量表中的变量也是重要的垃圾回收根节点,只要被局部变量表中直接或间接引用的对象都不会被回收。

#### 操作数栈(Operand Stack/表达式栈)

​   主要用于保存计算过程中的结果,同事作为计算过程中变量临时的存储空间。

​	操作数栈就是JVM执行引擎的工作区,当方法开始执行时被创建出来,刚开始栈是空的,长度在编译时已经确定。

​	栈中的元素32位以内的类型只占一个栈单位深度,64位的类型占2个栈单位深度

​	只能通过push和pop操作来完成数据访问。

#### 动态链接(Dynamic Linking/指向运行时常量池的方法引用) p59
{
静态链接:如果被调用的目标方法在编译期可知,且运行期保持不变,这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接(例如调用private,static方法和final方法,构造方法)invokeSpacial,invokeStatic

动态链接:反之无法在编译期被确定下来,只能在运行期将调用方法的符号引用转换为直接引用,由于这种引用转换过程具备动态性,因此也就被称为动态链接(涉及到父类或接口的抽象或者重写方法)ivokeVirtual,invokeInterface
}	

​	

#### 方法返回地址(Return Address/正常或者异常退出的定义)

正常退出 存放调用该方法的指令的下一条指令的地址

异常退出 异常表来决定

#### 一些附加信息（略)


## 06 方法的本地接口（native method）的理解p63
类似于接口，使得Java语言可以调用非Java语言写的方法，定义native方法并没有方法实现体，初衷是融合C/C++程序
## 07 堆 Heap

### 堆的核心概述

一个JVM实例只存在一个堆内存空间，堆也是Java内存管理的核心区域。

Java堆区在JVM启动的时候就被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。其大小是可以调节的。

《Java虚拟机规范》规定，堆可以处于物理上的不连续的内存空间中，但在逻辑上他应该被视为连续的。

所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer,TLAB）。

《Java虚拟机规范》中对堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。
其实是”几乎“所有

数组和对象可能永远不会存储在栈上，因为栈帧中保引用，这个引用指向对象或者数组在堆中的位置。

在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。

堆，是GC 执行垃圾回收的重点区域

内存细分:基于分代收集理论,堆空间逻辑上细分为年轻代,老年代,永久代Permanent Space(1.7)/Meta Space元空间(1.8)


### 设置堆内存大小与OOM
-Xms1024m 堆内存初始大小，默认为物理内存大小的1/64  
-Xmx2048m 堆内存最大值，默认为物理内存的1/4
### 年轻代（Young）与老年代（Old）
在JVM中java对象可以大致划分为2类  
一类是生命周期比较段的对象，创建和消亡都非常迅速  
另一类是生命周期相对较长的对象，有些个别的对象生命周期几乎与JVM生命周期保持一致  

JVM细分可划分为年轻代和老年代  
其中年轻代还可划分为Eden，Survivor0（from），Survivor1（to）区域

-XX:NewRatio=2设置老年代比新生代大小为2:1 默认新生代/老年代为1/2  
-XX:SurvivorRatio=4设置Eden比S0比S1 4:1:1，默认Eden比S0比S1是8:1:1

### 图解对象分配过程

### GC

### 堆空间的分代思想

### 内存分配策略

### 为对象分配内存TLAB

### 小结，堆空间的参数与设置

### 堆是分配对象的唯一选择吗？









 	







