# 第一章



# 第二章 类加载



# 第三章 运行时数据区

 



## 05 虚拟机栈

内存中的栈与堆,栈是运行时单位,堆是存储的单位

### 栈

每个线程都会创建一个虚拟机栈,内部保存一个个栈帧(StackFrame),对应这一次次的Java方法调用,是线程私有的

​	生命周期和线程一致

​	作用:主管Java程序的运行,保存方法的局部变量,部分结果,并参与调用和返回,决定了能调用方法的深度。

​	优点:一种快速有效的分配储存方式,速度仅次于程序计数器

​		JVM直接对Java栈操作只有入栈(每个方法执行),出栈(方法结束)
​		不存在垃圾回收问题

​	通过设置-Xss参数,来设置每个线程的栈内存大小

​    不同线程之间的栈帧不能互相引用

​    java有2种方法弹出栈,return 或者抛出异常。

### 栈帧

#### 局部变量表(Local Variables)

​	包括了,形参,局部变量(基本类型,对象引用),大小多少决定了方法被调用的深度

​	表的单个储存单位(Slot/变量槽),32位以内的类型只占一个,64位的类型占2个(long,double)

​	基本类型byte ,short ,char,boolean 也被转成int

​	构造方法/实例方法 会将当前对象this放在index为0的slot处

​	slot可以重复利用,当前面的局部变量过了作用域,后面申明的变量会重复使用之前变量的槽

​	局部变量表中的变量也是重要的垃圾回收根节点,只要被局部变量表中直接或间接引用的对象都不会被回收。

#### 操作数栈(Operand Stack/表达式栈)

​   主要用于保存计算过程中的结果,同事作为计算过程中变量临时的存储空间。

​	操作数栈就是JVM执行引擎的工作区,当方法开始执行时被创建出来,刚开始栈是空的,长度在编译时已经确定。

​	栈中的元素32位以内的类型只占一个栈单位深度,64位的类型占2个栈单位深度

​	只能通过push和pop操作来完成数据访问。

#### 动态链接(Dynamic Linking/指向运行时常量池的方法引用) p59
{
静态链接:如果被调用的目标方法在编译期可知,且运行期保持不变,这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接(例如调用private,static方法和final方法,构造方法)invokeSpacial,invokeStatic

动态链接:反之无法在编译期被确定下来,只能在运行期将调用方法的符号引用转换为直接引用,由于这种引用转换过程具备动态性,因此也就被称为动态链接(涉及到父类或接口的抽象或者重写方法)ivokeVirtual,invokeInterface
}	

​	

#### 方法返回地址(Return Address/正常或者异常退出的定义) 

正常退出 存放调用该方法的指令的下一条指令的地址

异常退出 异常表来决定

#### 一些附加信息（略)


## 06 方法的本地接口（native method）的理解p63
类似于接口，使得Java语言可以调用非Java语言写的方法，定义native方法并没有方法实现体，初衷是融合C/C++程序
## 07 堆 Heap

### 堆的核心概述

一个JVM实例只存在一个堆内存空间，堆也是Java内存管理的核心区域。

Java堆区在JVM启动的时候就被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。其大小是可以调节的。

《Java虚拟机规范》规定，堆可以处于物理上的不连续的内存空间中，但在逻辑上他应该被视为连续的。

所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer,TLAB）。

《Java虚拟机规范》中对堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。
其实是”几乎“所有

数组和对象可能永远不会存储在栈上，因为栈帧中保引用，这个引用指向对象或者数组在堆中的位置。

在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。

堆，是GC 执行垃圾回收的重点区域

内存细分:基于分代收集理论,堆空间逻辑上细分为年轻代,老年代,永久代Permanent Space(1.7)/Meta Space元空间(1.8)


### 设置堆内存大小与OOM
-Xms1024m 堆内存初始大小，默认为物理内存大小的1/64  
-Xmx2048m 堆内存最大值，默认为物理内存的1/4
### 年轻代（Young）与老年代（Old）
在JVM中java对象可以大致划分为2类  
一类是生命周期比较段的对象，创建和消亡都非常迅速  
另一类是生命周期相对较长的对象，有些个别的对象生命周期几乎与JVM生命周期保持一致  

JVM细分可划分为年轻代和老年代  
其中年轻代还可划分为Eden，Survivor0（from），Survivor1（to）区域

-XX:NewRatio=2设置老年代比新生代大小为2:1 默认新生代/老年代为1/2  
-XX:SurvivorRatio=4设置Eden比S0比S1 4:1:1，默认Eden比S0比S1是8:1:1  
-Xmn100m 设置新生代的大小

### 对象分配过程
#### 对象分配的理想情况(不考虑S0,S1和Old放不下的问题)
1,新生(new)的对象大多先分配在Eden区,此区域有大小限制  
2,当Eden区满了而程序又要创建对象时,JVM将对Eden区域执行YGC(youngGC/Minor GC),将Eden中不再被引用的对象销毁掉  
3.将Eden中剩余的对象移动到to区,并且将from区的对象也移动到to区,S0和S1都可以是from区或者to区每次YGC互换角色？（还未确定，视频教程感觉不是非常靠谱）
4.再加载新的对象至Eden  
5.将to区的对象年龄+1,当对象的年龄超过阈值之后放入老年代Old,默认阈值是15次  
-XX:MaxTenuringThreshold=15进行设置去老年代的阈值
#### 对象分配的特殊情况
1.Eden满了，触发YGC  
2.YGC:剩余的存活对象如果to区放不下，则放到老年代中。  
如果老年代也放不下就触发FGC（FullGC）如果FGC之后还是放不下就OOM  
3.如果超大对象大于Eden了，尝试放老年代，老年代放不下触发FullGC，还是放不下OOM

### GC
MinorGC(YGC)、MajorGC、FullGC
JVM在进行GC时并非每次都对新生代,老年代,方法区都进行GC,大部分的时候GC指的都是新生代  
针对HotSpot的JVM实现,其中的GC按区域划分2大类型,一种是整体的回收Full GC,一种是部分的回收Partial GC
#### 部分收集又分为
##### 新生代(Young GC/Minor GC)  
只对Eden和S0,S1进行GC
##### 老年代(Major GC/Old GC)  
只对老年代的GC  
目前之后CMS GC会有单独收集老年代的行为  
很多时候Major GC会和Full GC一起混淆使用,需要具体分辨是Old GC 还是Full GC
##### 混合收集(Mixed GC) 
整个新生代和部分老年代的垃圾收集,目前只有G1 GC会有这种行为

##### 整堆收集
收集整个Java堆和方法区的垃圾收集

#### Minor GC 触发机制
当年轻代不足时会触发Minor GC,指Eden不足。(Survivor 只有在GC时才会不足,对象往老年代分)  
Minor GC频率比较高,回收速度也很快  

Minor GC会引发STW(Stop the World),暂停用户线程,等垃圾回收结束,再恢复线程运行  

#### Major GC 触发机制  
指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（非绝对，Parallel Scavenge 收集器的收集策略里就有直接进行Major GC的策略选择过程）。
也就是说，在老年代空间不足时，会先尝试出发Minor GC，如果之后空间还不足，则出发Major GC。（感觉讲者有误，本来触发老年代GC就是因为Minor GC 过来，再触发老年代GC）  
Major GC 的速度一般会比Minor GC 慢10倍以上，也会触发STW  
如果Major GC 后内存还是不够创建对象，就OOM

#### Full GC 触发机制
1.调用System.gc()时，系统建议执行Full GC，但是不必然执行
2.老年代空间不足
3.方法区空间不足
4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5.Minor GC时 对象转到老年代，对象大于老年代的可用内存（感觉和2重复了）

### 堆空间的分代思想

### 内存分配策略

### 为对象分配内存TLAB

### 小结，堆空间的参数与设置

### 堆是分配对象的唯一选择吗？









 	







